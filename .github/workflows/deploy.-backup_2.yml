# ------------------------------------------------------------------------------
# Reusable: Deploy to Railway
# ------------------------------------------------------------------------------
# Deploys container images from GHCR to Railway. Uses minimal API (image update)
# and health-check polling for completion. Railway CLI cannot update source
# imageâ€”API is required for pre-built GHCR images.
#
# NOT auto-triggered. Call via: ci-cd-pipeline.yml
# Requires: RAILWAY_TOKEN, RAILWAY_URL, RAILWAY_PROJECT_ID (or in config)
# ------------------------------------------------------------------------------

name: "Deploy to Railway"

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: false
        default: production
        type: string
      tag:
        description: 'Container tag (e.g., v0.3.0, latest)'
        required: false
        default: latest
        type: string
    secrets:
      RAILWAY_TOKEN:
        required: true
      RAILWAY_PROJECT_ID:
        required: false
      RAILWAY_URL:
        required: false

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: false
        default: production
        type: choice
        options: [production, staging]
      tag:
        description: 'Container tag'
        required: false
        default: latest
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/research-auditor

jobs:
  deploy:
    name: Deploy to Railway
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Load config and set params
        id: setup
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          TAG: ${{ inputs.tag }}
        run: |
          CONFIG="deploy/railway/${ENVIRONMENT}.yml"
          [ -f "$CONFIG" ] || { echo "âŒ Config not found: $CONFIG"; exit 1; }
          SERVICE_NAME=$(yq eval '.railway.service_name' "$CONFIG")
          START_CMD=$(yq eval '.railway.container.start_command' "$CONFIG")
          PROJECT_ID=$(yq eval '.railway.project_id // ""' "$CONFIG" 2>/dev/null || true)
          [ -z "$PROJECT_ID" ] && PROJECT_ID="${{ secrets.RAILWAY_PROJECT_ID }}"
          [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" = "null" ] && { echo "âŒ service_name not found"; exit 1; }
          [ -z "$PROJECT_ID" ] && { echo "âŒ project_id not set"; exit 1; }
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "start_command=$START_CMD" >> $GITHUB_OUTPUT
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ $ENVIRONMENT | Tag: $TAG"

      - name: Verify image exists
        run: |
          docker manifest inspect ${{ steps.setup.outputs.image }} > /dev/null 2>&1 || { echo "âŒ Image not found"; exit 1; }
          echo "âœ… Image found"

      - name: Get Railway service ID
        id: railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          PROJECT_ID: ${{ steps.setup.outputs.project_id }}
          SERVICE_NAME: ${{ steps.setup.outputs.service_name }}
        run: |
          PAYLOAD=$(jq -n --arg id "$PROJECT_ID" '{query: "query project($id: String!) { project(id: $id) { services { edges { node { id name } } } } }", variables: {id: $id}}')
          BODY=$(curl -sS -X POST https://backboard.railway.com/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          echo "$BODY" | jq -e '.errors' > /dev/null 2>&1 && { echo "âŒ API error:"; echo "$BODY" | jq '.errors'; exit 1; }
          SID=$(echo "$BODY" | jq -r ".data.project.services.edges[].node | select(.name == \"$SERVICE_NAME\") | .id")
          [ -z "$SID" ] || [ "$SID" = "null" ] && { echo "âŒ Service not found: $SERVICE_NAME"; exit 1; }
          echo "service_id=$SID" >> $GITHUB_OUTPUT
          echo "âœ… Service ID resolved"

      - name: Trigger deployment
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          IMAGE: ${{ steps.setup.outputs.image }}
          SID: ${{ steps.railway.outputs.service_id }}
          START_CMD: ${{ steps.setup.outputs.start_command }}
        run: |
          PAYLOAD=$(jq -n \
            --arg sid "$SID" --arg img "$IMAGE" --arg cmd "$START_CMD" \
            '{query: "mutation serviceInstanceUpdate($serviceId: String!, $input: ServiceInstanceUpdateInput!) { serviceInstanceUpdate(serviceId: $serviceId, input: $input) { id } }", variables: {serviceId: $sid, input: {source: {image: $img}, startCommand: $cmd}}}')
          BODY=$(curl -sS -X POST https://backboard.railway.com/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          echo "$BODY" | jq -e '.errors' > /dev/null 2>&1 && { echo "âŒ Deploy failed:"; echo "$BODY" | jq '.errors'; exit 1; }
          echo "âœ… Deployment triggered"

      - name: Wait for deployment
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          RAILWAY_URL: ${{ secrets.RAILWAY_URL }}
          SERVICE_ID: ${{ steps.railway.outputs.service_id }}
        run: |
          MAX=300
          INTERVAL=10
          ELAPSED=0

          if [[ -n "${RAILWAY_URL:-}" ]]; then
            echo "Using health-check polling: $RAILWAY_URL"
            while [ $ELAPSED -lt $MAX ]; do
              if curl -sfS -m 10 "$RAILWAY_URL/health" > /dev/null 2>&1 || curl -sfS -m 10 "$RAILWAY_URL/" > /dev/null 2>&1; then
                echo "âœ… Deployment healthy (${ELAPSED}s)"
                exit 0
              fi
              echo "   Waiting... ${ELAPSED}s"
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
          else
            echo "RAILWAY_URL not set; using GraphQL status polling"
            while [ $ELAPSED -lt $MAX ]; do
              BODY=$(curl -sS -X POST https://backboard.railway.com/graphql/v2 \
                -H "Authorization: Bearer $RAILWAY_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"query\":\"query{service(id:\\\"$SERVICE_ID\\\"){deployments(first:1){edges{node{status}}}}}\",\"variables\":{}}")
              STATUS=$(echo "$BODY" | jq -r '.data.service.deployments.edges[0].node.status // "UNKNOWN"')
              echo "   Status: $STATUS (${ELAPSED}s)"
              case "$STATUS" in
                SUCCESS) echo "âœ… Deployment succeeded!"; exit 0 ;;
                FAILED|CRASHED) echo "âŒ Deployment failed"; exit 1 ;;
              esac
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
          fi
          echo "âš ï¸ Timeout"; exit 1

      - name: Summary
        if: always()
        run: |
          echo "## Railway Deployment ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ steps.setup.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY

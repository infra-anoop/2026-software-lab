# ---------------------------------------------------------------------------
# .github/workflows/deploy.yml
# ---------------------------------------------------------------------------
# Reusable + manual deploy workflow for Railway.
#
# Reads deploy/railway/<environment>.yml (e.g. production.yml)
# Resolves Railway project/service IDs by NAME (no hardcoded IDs)
# Triggers deploy from GHCR image tag (default: latest)
# Waits for terminal deployment state before succeeding.
#
# Requires:
#   - GitHub Secret: RAILWAY_TOKEN
# ---------------------------------------------------------------------------

name: Deploy to Railway

on:
  workflow_call:
    inputs:
      tag:
        description: "GHCR tag to deploy (default: latest)"
        required: false
        type: string
        default: latest
      environment:
        description: "Deployment config name (production/staging). Default: production"
        required: false
        type: string
        default: production

  workflow_dispatch:
    inputs:
      tag:
        description: "GHCR tag to deploy (default: latest)"
        required: false
        type: string
        default: latest
      environment:
        description: "Deployment config name (production/staging). Default: production"
        required: false
        type: choice
        options: [production, staging]
        default: production

concurrency:
  group: railway-deploy-${{ github.ref }}-${{ inputs.environment || 'production' }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq + yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Resolve inputs
        id: params
        run: |
          TAG="${{ inputs.tag || 'latest' }}"
          ENV_CONFIG="${{ inputs.environment || 'production' }}"

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "env_config=$ENV_CONFIG" >> "$GITHUB_OUTPUT"

          echo "Deploy params:"
          echo "  tag: $TAG"
          echo "  env_config: $ENV_CONFIG"

      - name: Load Railway deploy config
        id: cfg
        env:
          ENV_CONFIG: ${{ steps.params.outputs.env_config }}
          TAG: ${{ steps.params.outputs.tag }}
        run: |
          CONFIG_FILE="deploy/railway/${ENV_CONFIG}.yml"
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Missing config: $CONFIG_FILE"
            ls -la deploy/railway || true
            exit 1
          fi

          PROJECT_NAME=$(yq -r '.railway.project_name' "$CONFIG_FILE")
          SERVICE_NAME=$(yq -r '.railway.service_name' "$CONFIG_FILE")
          ENV_NAME=$(yq -r '.railway.environment_name' "$CONFIG_FILE")

          REGISTRY=$(yq -r '.image.registry' "$CONFIG_FILE")
          REPOSITORY=$(yq -r '.image.repository' "$CONFIG_FILE")
          START_CMD=$(yq -r '.runtime.start_command' "$CONFIG_FILE")

          # Substitute our config template tokens
          REPOSITORY="${REPOSITORY//\{\{ github_repository_owner \}\}/${{ github.repository_owner }}}"

          if [ -z "$PROJECT_NAME" ] || [ "$PROJECT_NAME" = "null" ]; then
            echo "âŒ railway.project_name missing in $CONFIG_FILE"; exit 1
          fi
          if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" = "null" ]; then
            echo "âŒ railway.service_name missing in $CONFIG_FILE"; exit 1
          fi
          if [ -z "$ENV_NAME" ] || [ "$ENV_NAME" = "null" ]; then
            echo "âŒ railway.environment_name missing in $CONFIG_FILE"; exit 1
          fi
          if [ -z "$REGISTRY" ] || [ "$REGISTRY" = "null" ]; then
            echo "âŒ image.registry missing in $CONFIG_FILE"; exit 1
          fi
          if [ -z "$REPOSITORY" ] || [ "$REPOSITORY" = "null" ]; then
            echo "âŒ image.repository missing in $CONFIG_FILE"; exit 1
          fi

          IMAGE_REF="${REGISTRY}/${REPOSITORY}:${TAG}"

          echo "project_name=$PROJECT_NAME" >> "$GITHUB_OUTPUT"
          echo "service_name=$SERVICE_NAME" >> "$GITHUB_OUTPUT"
          echo "environment_name=$ENV_NAME" >> "$GITHUB_OUTPUT"
          echo "image_ref=$IMAGE_REF" >> "$GITHUB_OUTPUT"
          echo "start_command=$START_CMD" >> "$GITHUB_OUTPUT"

          echo "Config loaded:"
          echo "  project: $PROJECT_NAME"
          echo "  service: $SERVICE_NAME"
          echo "  environment: $ENV_NAME"
          echo "  image: $IMAGE_REF"

      - name: Login to GHCR (for manifest lookup)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image exists in GHCR
        env:
          IMAGE_REF: ${{ steps.cfg.outputs.image_ref }}
        run: |
          echo "ðŸ” Checking image: $IMAGE_REF"
          if docker manifest inspect "$IMAGE_REF" >/dev/null 2>&1; then
            echo "âœ… Image exists"
            DIGEST=$(docker manifest inspect "$IMAGE_REF" | jq -r '.manifests[0].digest // empty')
            if [ -n "$DIGEST" ]; then
              echo "Digest: $DIGEST"
            fi
          else
            echo "âŒ Image not found: $IMAGE_REF"
            exit 1
          fi

      - name: Resolve Railway IDs (project + service)
        id: ids
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          PROJECT_NAME: ${{ steps.cfg.outputs.project_name }}
          SERVICE_NAME: ${{ steps.cfg.outputs.service_name }}
        run: |
          set -euo pipefail

          API="https://backboard.railway.app/graphql/v2"

          call_api () {
            curl -sS -X POST "$API" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$1"
          }

          echo "ðŸ” Finding project ID for: $PROJECT_NAME"
          PROJECT_RESP=$(call_api '{"query":"{ projects { edges { node { id name } } } }"}')
          if echo "$PROJECT_RESP" | jq -e '.errors' >/dev/null 2>&1; then
            echo "âŒ Railway API errors:"; echo "$PROJECT_RESP" | jq '.errors'; exit 1
          fi

          PROJECT_ID=$(echo "$PROJECT_RESP" | jq -r --arg n "$PROJECT_NAME" '.data.projects.edges[].node | select(.name==$n) | .id' | head -n 1)
          if [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ]; then
            echo "âŒ Project not found: $PROJECT_NAME"
            echo "Available projects:"; echo "$PROJECT_RESP" | jq -r '.data.projects.edges[].node.name' | sed 's/^/  - /'
            exit 1
          fi
          echo "âœ… Project ID: $PROJECT_ID"

          echo "ðŸ” Finding service ID for: $SERVICE_NAME"
          SERVICE_RESP=$(call_api "{\"query\":\"{ project(id:\\\"$PROJECT_ID\\\") { services { edges { node { id name } } } } }\"}")
          if echo "$SERVICE_RESP" | jq -e '.errors' >/dev/null 2>&1; then
            echo "âŒ Railway API errors:"; echo "$SERVICE_RESP" | jq '.errors'; exit 1
          fi

          SERVICE_ID=$(echo "$SERVICE_RESP" | jq -r --arg n "$SERVICE_NAME" '.data.project.services.edges[].node | select(.name==$n) | .id' | head -n 1)
          if [ -z "$SERVICE_ID" ] || [ "$SERVICE_ID" = "null" ]; then
            echo "âŒ Service not found: $SERVICE_NAME"
            echo "Available services:"; echo "$SERVICE_RESP" | jq -r '.data.project.services.edges[].node.name' | sed 's/^/  - /'
            exit 1
          fi
          echo "âœ… Service ID: $SERVICE_ID"

          echo "project_id=$PROJECT_ID" >> "$GITHUB_OUTPUT"
          echo "service_id=$SERVICE_ID" >> "$GITHUB_OUTPUT"

      - name: Trigger Railway deployment and wait
        id: deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          SERVICE_ID: ${{ steps.ids.outputs.service_id }}
          ENV_NAME: ${{ steps.cfg.outputs.environment_name }}
          IMAGE_REF: ${{ steps.cfg.outputs.image_ref }}
          START_COMMAND: ${{ steps.cfg.outputs.start_command }}
        run: |
          set -euo pipefail

          API="https://backboard.railway.app/graphql/v2"

          call_api () {
            curl -sS -X POST "$API" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$1"
          }

          echo "ðŸš€ Triggering deployment"
          echo "  service_id: $SERVICE_ID"
          echo "  environment: $ENV_NAME"
          echo "  image: $IMAGE_REF"

          # NOTE: Railway's GraphQL schema can evolve. If this mutation name differs
          # in your project, adjust only this block.
          MUTATION=$(jq -n \
            --arg serviceId "$SERVICE_ID" \
            --arg environmentName "$ENV_NAME" \
            --arg image "$IMAGE_REF" \
            --arg startCommand "$START_COMMAND" \
            '{
              query: "mutation Deploy($serviceId: String!, $environmentName: String!, $image: String!, $startCommand: String) { serviceInstanceDeploy(input:{ serviceId:$serviceId, environmentName:$environmentName, image:$image, startCommand:$startCommand }) { id } }",
              variables: {
                serviceId: $serviceId,
                environmentName: $environmentName,
                image: $image,
                startCommand: $startCommand
              }
            }')

          RESP=$(call_api "$MUTATION")
          if echo "$RESP" | jq -e '.errors' >/dev/null 2>&1; then
            echo "âŒ Deploy call failed:"; echo "$RESP" | jq '.errors'; exit 1
          fi

          DEPLOY_ID=$(echo "$RESP" | jq -r '.data.serviceInstanceDeploy.id // empty')
          if [ -z "$DEPLOY_ID" ]; then
            echo "âŒ No deployment id returned. Full response:"; echo "$RESP" | jq
            exit 1
          fi

          echo "deployment_id=$DEPLOY_ID" >> "$GITHUB_OUTPUT"
          echo "âœ… Deployment started: $DEPLOY_ID"

          echo "â³ Waiting for deployment to complete..."
          MAX_WAIT=900
          INTERVAL=10
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            Q=$(jq -n --arg id "$DEPLOY_ID" '{ query: "query($id: String!) { deployment(id:$id) { status } }", variables: { id: $id } }')
            R=$(call_api "$Q")

            STATUS=$(echo "$R" | jq -r '.data.deployment.status // "UNKNOWN"')
            echo "Status: $STATUS (${ELAPSED}s)"

            case "$STATUS" in
              ACTIVE|SUCCESS)
                echo "âœ… Deployment complete: $STATUS"
                exit 0
                ;;
              FAILED|CRASHED|ERROR)
                echo "âŒ Deployment failed: $STATUS"
                exit 1
                ;;
              *)
                sleep $INTERVAL
                ELAPSED=$((ELAPSED + INTERVAL))
                ;;
            esac
          done

          echo "âŒ Timed out waiting for deployment after ${MAX_WAIT}s"
          exit 1

      - name: Summary
        if: always()
        run: |
          {
            echo "## Railway Deploy"
            echo "- **Project:** ${{ steps.cfg.outputs.project_name }}"
            echo "- **Service:** ${{ steps.cfg.outputs.service_name }}"
            echo "- **Environment:** ${{ steps.cfg.outputs.environment_name }}"
            echo "- **Image:** \`${{ steps.cfg.outputs.image_ref }}\`"
            if [ -n "${{ steps.deploy.outputs.deployment_id }}" ]; then
              echo "- **Deployment ID:** \`${{ steps.deploy.outputs.deployment_id }}\`"
            fi
            echo "- **Status:** ${{ job.status }}"
            echo ""
            echo "**Links**"
            echo "- Railway Dashboard: https://railway.app"
            echo "- GHCR Package: https://github.com/${{ github.repository }}/pkgs/container/research-auditor"
          } >> "$GITHUB_STEP_SUMMARY"
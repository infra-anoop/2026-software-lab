# ------------------------------------------------------------------------------
# BACKUP: Original Deploy to Railway (API-based)
# ------------------------------------------------------------------------------
# Saved for comparison. This uses Railway GraphQL API for:
#   - Service ID lookup
#   - serviceInstanceUpdate (set image + start_command, trigger deploy)
#   - Deployment status polling
#
# To restore: mv deploy_api_backup.uml deploy.yml
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Reusable: Deploy to Railway
# ------------------------------------------------------------------------------
# Deploys container images from GHCR to Railway via GraphQL API.
# NOT auto-triggered. Call via: ci-cd-pipeline.yml
# Requires: RAILWAY_TOKEN, container in GHCR
# ------------------------------------------------------------------------------

name: "Deploy to Railway"

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: false
        default: production
        type: string
      tag:
        description: 'Container tag (e.g., v0.3.0, latest)'
        required: false
        default: latest
        type: string
    secrets:
      RAILWAY_TOKEN:
        required: true
      RAILWAY_PROJECT_ID:
        required: false

  workflow_dispatch:  # Manual run only; no auto-trigger
    inputs:
      environment:
        description: 'Environment'
        required: false
        default: production
        type: choice
        options: [production, staging]
      tag:
        description: 'Container tag'
        required: false
        default: latest
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/research-auditor

jobs:
  deploy:
    name: Deploy to Railway
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq (YAML parser)
        run: |
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Set deployment parameters
        id: params
        run: |
          ENVIRONMENT="${{ inputs.environment }}"
          TAG="${{ inputs.tag }}"

          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Deploying: $ENVIRONMENT"
          echo "ðŸ·ï¸  Tag: $TAG"

      - name: Load Railway configuration
        id: config
        env:
          ENVIRONMENT: ${{ steps.params.outputs.environment }}
        run: |
          CONFIG_FILE="deploy/railway/${ENVIRONMENT}.yml"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Configuration file not found: $CONFIG_FILE"
            ls -la deploy/railway/
            exit 1
          fi

          SERVICE_NAME=$(yq eval '.railway.service_name' "$CONFIG_FILE")
          START_CMD=$(yq eval '.railway.container.start_command' "$CONFIG_FILE")
          PROJECT_ID=$(yq eval '.railway.project_id // ""' "$CONFIG_FILE" 2>/dev/null || true)
          if [ -z "$PROJECT_ID" ]; then
            PROJECT_ID="${{ secrets.RAILWAY_PROJECT_ID }}"
          fi

          if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" == "null" ]; then
            echo "âŒ service_name not found in config"
            exit 1
          fi
          if [ -z "$PROJECT_ID" ]; then
            echo "âŒ project_id not set. Add railway.project_id in config or RAILWAY_PROJECT_ID secret."
            exit 1
          fi

          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "start_command=$START_CMD" >> $GITHUB_OUTPUT
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Verify container image exists
        env:
          IMAGE: ${{ steps.params.outputs.image }}
        run: |
          echo "ðŸ” Verifying image exists: $IMAGE"
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 || {
            echo "âŒ Image not found: $IMAGE"
            exit 1
          }
          echo "âœ… Image found"

      - name: Get Railway service ID
        id: railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          SERVICE_NAME: ${{ steps.config.outputs.service_name }}
          PROJECT_ID: ${{ steps.config.outputs.project_id }}
        run: |
          QUERY=$(jq -n --arg id "$PROJECT_ID" '{query: "query project($id: String!) { project(id: $id) { services { edges { node { id name } } } } }", variables: {id: $id}}')
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://backboard.railway.com/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$QUERY")
          HTTP_BODY="${RESPONSE%$'\n'*}"
          HTTP_CODE="${RESPONSE##*$'\n'}"

          if ! echo "$HTTP_BODY" | jq -e . > /dev/null 2>&1; then
            echo "âŒ Railway API returned invalid JSON (HTTP $HTTP_CODE)"
            echo "Response: $HTTP_BODY"
            exit 1
          fi
          if echo "$HTTP_BODY" | jq -e '.errors' > /dev/null 2>&1; then
            echo "âŒ Railway API error:" && echo "$HTTP_BODY" | jq '.errors'
            exit 1
          fi

          SERVICE_ID=$(echo "$HTTP_BODY" | jq -r ".data.project.services.edges[] | select(.node.name == \"$SERVICE_NAME\") | .node.id")
          if [ -z "$SERVICE_ID" ] || [ "$SERVICE_ID" == "null" ]; then
            echo "âŒ Service not found: $SERVICE_NAME"
            exit 1
          fi
          echo "service_id=$SERVICE_ID" >> $GITHUB_OUTPUT

      - name: Trigger Railway deployment
        id: deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          SERVICE_ID: ${{ steps.railway.outputs.service_id }}
          IMAGE: ${{ steps.params.outputs.image }}
          START_COMMAND: ${{ steps.config.outputs.start_command }}
        run: |
          MUTATION=$(jq -n \
            --arg serviceId "$SERVICE_ID" \
            --arg image "$IMAGE" \
            --arg startCommand "$START_COMMAND" \
            '{query: "mutation serviceInstanceUpdate($serviceId: String!, $input: ServiceInstanceUpdateInput!) { serviceInstanceUpdate(serviceId: $serviceId, input: $input) { id } }", variables: {serviceId: $serviceId, input: {source: {image: $image}, startCommand: $startCommand}}}')

          RESPONSE=$(curl -s -X POST https://backboard.railway.com/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$MUTATION")

          if echo "$RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
            echo "âŒ Deployment failed:" && echo "$RESPONSE" | jq '.errors'
            exit 1
          fi

          DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.data.serviceInstanceUpdate.id')
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "âœ… Deployment triggered"

      - name: Wait for deployment to complete
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          SERVICE_ID: ${{ steps.railway.outputs.service_id }}
        run: |
          MAX_WAIT=300
          INTERVAL=15
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            QUERY=$(jq -n --arg id "$SERVICE_ID" '{query: "query service($id: String!) { service(id: $id) { deployments(first: 1) { edges { node { status } } } } }", variables: {id: $id}}')
            RESPONSE=$(curl -s -X POST https://backboard.railway.com/graphql/v2 \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$QUERY")
            STATUS=$(echo "$RESPONSE" | jq -r '.data.service.deployments.edges[0].node.status // "UNKNOWN"')

            echo "   Status: $STATUS (${ELAPSED}s)"

            case "$STATUS" in
              "SUCCESS") echo "âœ… Deployment succeeded!"; exit 0 ;;
              "FAILED"|"CRASHED") echo "âŒ Deployment failed"; exit 1 ;;
            esac
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          echo "âš ï¸ Timeout"; exit 1

      - name: Generate summary
        if: always()
        run: |
          echo "## Railway Deployment ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ steps.params.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
